unit Serialize.Json4D;

interface

uses
  System.Generics.Collections,
  Contracts.Json4D;

type
  TJson4DSerialize<T: Class, constructor> = class(TInterfacedObject,
    ISerializeJSON4D<T>)
  private
    FJson: IJSONCore<T>;
  public
    constructor Create;
    Destructor Destroy; override;
    function ObjectToJsonArray(AObject: TObjectList<T>): IJSONCore<T>; overload;
    function ObjectToJsonArray(AObject: TObject): IJSONCore<T>; overload;
    class function New: ISerializeJSON4D<T>;
  end;

implementation

uses
  System.SysUtils,
  System.RTTI,
  Serialize.Core.Json4D,
  RTTI.Attributes.Json4D,
  Types.Enums.Json4D;
{ TJson4DSerialize<T> }

constructor TJson4DSerialize<T>.Create;
begin
  FJson := TJSON4DCore<T>.New;
end;

destructor TJson4DSerialize<T>.Destroy;
begin

  inherited;
end;

class function TJson4DSerialize<T>.New: ISerializeJSON4D<T>;
begin
  Result := Self.Create;
end;

function TJson4DSerialize<T>.ObjectToJsonArray(AObject: TObject): IJSONCore<T>;
var
  context: TRttiContext;
  typeRtti: TRttiType;
  fldRTTI: TRttiField;
  lAttributes: TCustomAttribute;
begin
  context := TRttiContext.Create;
  try
    typeRtti := context.GetType(AObject.ClassInfo);
    for fldRTTI in typeRtti.GetFields do
      for lAttributes in fldRTTI.GetAttributes do
      begin
        if lAttributes is ArrayObjects then
        begin
          case ArrayObjects(lAttributes).TypeArray of

          end;
        end;
      end;

    fldRTTI.GetValue(AObject).AsType<TObjectList<T>>;

  finally
    context.Free;
  end;
  Result := FJson;
end;

function TJson4DSerialize<T>.ObjectToJsonArray(AObject: TObjectList<T>)
  : IJSONCore<T>;
var
  I: Integer;
begin
  Result := EmptyStr;
  for I := 0 to pred(AObject.Count) do
    FJson.Add(AObject.Items[I]);
  Result := FJson;
end;

end.
